#
# FreeCAD Python Macro to generate space frame components
#
# Adrian Bowyer
# reprapltd.com
#
# 6 February 2020
#
# Licence: GPL
#

import Part, FreeCAD, math
from FreeCAD import Base
import math

# User Parameters

# The thicknesses of the spars

sparThickness = 4

# The width of the frame

frameWidth = 40

# The length of the frame

frameLength = 250

# Embed nuts in the screw holes?

embeddedNuts = False

# And in the corners?

embeddedNutsInCorners = True

# The Y offset for the screw tabs from the centre

tabYOffset = 5

# How far apart printed mating faces have to be to just touch. Also added to small radii to get clearance.

clearance = 0.2

# Usually M3

screwRadius = 1.5

#Square nut cavity

nutXY = 5.8
nutZ = 2
nutWalls = 2


#********************************************************************************

# Fixed and derived values

clipLength = 7
clipWidth = 2

halfSparThickness = sparThickness/2
halfFrameWidth = frameWidth/2
halfClipWidth = clipWidth/2
halfClipLength = clipLength/2

shortenedFrameWidth = frameWidth - sparThickness

# All the structure is equilateral triangles

r3 = math.sqrt(3)

#********************************************************************************

# There must be an easier way to make the null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a length of blank spar along the X axis with its base at Z=0 and the centre
# of its end touching the Z axis

def BlankSpar(length):
 bs = Part.makeBox(length, sparThickness, sparThickness)
 bs.translate(Base.Vector(0, -halfSparThickness, 0))
 return bs


# Make a spar between two points

def Spar(p0, p1):
 p = p1.sub(p0)
 length = math.sqrt(p.x*p.x + p.y*p.y)
 bs = BlankSpar(length)
 angle = math.atan2(p.y, p.x)
 bs.rotate(Base.Vector(0, 0, 0), Base.Vector(0, 0, 1), angle*180/math.pi)
 bs.translate(p0)
 return bs


# Screw fastening at the point p and the hole in it

def ScrewFastening(p, square):
 if square:
  tab = Part.makeBox(nutXY + 2*nutWalls, nutXY + 2*nutWalls, sparThickness)
  pt = p.add(Base.Vector(-nutXY/2 - nutWalls, -nutXY/2 - nutWalls, 0))
  tab.translate(pt)
 else:
  tab = Part.makeCylinder(screwRadius + nutWalls, sparThickness)
  tab.translate(p)
 return tab

def ScrewHole(p, square):
 hole = Part.makeCylinder(screwRadius, 3*sparThickness, p.sub(Base.Vector(0, 0, sparThickness)), Base.Vector(0, 0, 1))
 if square:
  nut = Part.makeBox(nutXY, nutXY, nutZ)
  pt = p.add(Base.Vector(-nutXY/2, -nutXY/2, (sparThickness - nutZ)/2))
  nut.translate(pt)
  hole = hole.fuse(nut)
 return hole


# Clips

def FemaleClip():
 fc1 = Part.makeBox(clipLength, clipWidth, sparThickness)
 fc1.translate(Base.Vector(0, -halfClipWidth - halfClipLength, 0))
 fc2 = Part.makeBox(clipLength, clipWidth, sparThickness)
 fc2.translate(Base.Vector(0, -halfClipWidth + halfClipLength, 0))
 return fc1.fuse(fc2)

def FemaleClipCut():
 fcc = Part.makeBox(clipLength+2, clipLength, sparThickness+2)
 fcc.translate(Base.Vector(0, - halfClipLength, -1))
 return fcc

def MaleClip():
 fc1 = Part.makeBox(clipLength, clipWidth, sparThickness)
 fc1.translate(Base.Vector(0, -halfClipWidth - halfClipLength, 0))
 fc2 = Part.makeBox(clipLength, clipWidth, sparThickness)
 fc2.translate(Base.Vector(0, -halfClipWidth + halfClipLength, 0))
 return fc1.fuse(fc2)

def MaleClipCut():
 mcc = Part.makeBox(clipLength+2, clipLength, sparThickness+2)
 mcc.translate(Base.Vector(0, - halfClipLength, -1))
 return fcc


# The 30 degree chamfer where the edges fit together

def Chamfer30Cut():
 halfAngle1 = Part.makeBox(frameLength+10, frameWidth, frameWidth)
 halfAngle1.rotate(Base.Vector(0, 0, 0), Base.Vector(1, 0, 0), 30)
 halfAngle1.translate(Base.Vector(-5, -halfFrameWidth, 0))
 halfAngle2 = Part.makeBox(frameLength+10, frameWidth, frameWidth)
 halfAngle2.rotate(Base.Vector(0, 0, 0), Base.Vector(1, 0, 0), 30)
 halfAngle2.translate(Base.Vector(-5, -halfFrameWidth, 0))
 halfAngle2 = halfAngle2.mirror(Base.Vector(0,0,0), Base.Vector(0,1,0))
 return halfAngle1.fuse(halfAngle2)



# Make one face of the Frame

def FrameFace():

 # The outer rectangle

 p0 = Base.Vector(halfSparThickness, -0.5*frameWidth, 0)
 p1 = p0.add(Base.Vector(0, frameWidth, 0))
 frame = Spar(p0, p1)
 p0 = Base.Vector(0, 0.5*frameWidth - halfSparThickness, 0)
 p1 = p0.add(Base.Vector(frameLength, 0, 0))
 frame = frame.fuse(Spar(p0, p1))
 p0 = Base.Vector(frameLength - halfSparThickness, 0.5*frameWidth, 0)
 p1 = p0.add(Base.Vector(0, -frameWidth, 0))
 frame = frame.fuse(Spar(p0, p1))
 p0 = Base.Vector(frameLength, -0.5*frameWidth + halfSparThickness, 0)
 p1 = p0.add(Base.Vector(-frameLength, 0, 0))
 frame = frame.fuse(Spar(p0, p1))
 
 # These vectors are added to increment the triangle edges

 p0 = Base.Vector(halfSparThickness, -0.5*frameWidth + halfSparThickness, 0)
 pUp = Base.Vector(shortenedFrameWidth/r3, shortenedFrameWidth, 0)
 pDown = Base.Vector(shortenedFrameWidth/r3, -shortenedFrameWidth, 0)
 triangles = Null()

 # How far do we go in the X direction along the frame?

 if embeddedNuts:
  xCheck = frameLength - sparThickness - nutXY - nutWalls
 else:
  xCheck = frameLength - sparThickness - screwRadius - nutWalls

# Loop, adding triangle edges and other features until we hit the end
# Note one more edge may be on the end, which will be truncated, if
# The length is such that there aren't an exact multiple of triangles along the frame.

 count = 1
 while p0.x < frameLength:

  # The other end of this spar

  p1 = p0.add(pUp)

  # Mess about making sure any screw holes are on an integer
  # coordinate grid so other things can connect to them. Note that
  # this means that the screw holes will go out of place relative to the 
  # triangle edges on very long frames.

  if count < 2:
   tab = p0.add(p1).multiply(0.5)
   tab = tab.add(Base.Vector(tabYOffset/r3, tabYOffset, 0))
   tab = Base.Vector(round(tab.x), tabYOffset, 0)
  elif count == 2:
   tab = p0.add(p1).multiply(0.5)
   tab = tab.add(Base.Vector(tabYOffset/r3, tabYOffset, 0))
   tab = Base.Vector(round(tab.x), tabYOffset, 0)
   xIncrement = tab.x - oldUpX
  else:
   tab = Base.Vector(oldUpX + xIncrement, tabYOffset, 0)
  oldUpX = tab.x

  # The actual triangle leg

  triangles = triangles.fuse(Spar(p0, p1))

  # Add a srew fastening to it

  if tab.x < xCheck:
   triangles = triangles.fuse(ScrewFastening(tab, embeddedNuts))
   triangles = triangles.cut(ScrewHole(tab, embeddedNuts))

  # Now down the other side of the triangle. This is pretty much identical apart from 
  # some signs to the code just above.

  p0 = p1
  p1 = p0.add(pDown)
  if count < 2:
   tab = p0.add(p1).multiply(0.5)
   tab = tab.add(Base.Vector(tabYOffset/r3, -tabYOffset, 0))
   tab = Base.Vector(round(tab.x), -tabYOffset, 0)
  else:
   tab = Base.Vector(oldDownX + xIncrement, -tabYOffset, 0)
  oldDownX = tab.x
  triangles = triangles.fuse(Spar(p0, p1))
  if tab.x < xCheck:
   triangles = triangles.fuse(ScrewFastening(tab, embeddedNuts))
   triangles = triangles.cut(ScrewHole(tab, embeddedNuts))
  p0 = p1
  count = count + 1

 # Cut the last leg, if need be, so it fits within the frame.

 chop = Part.makeBox(frameLength + 10, 2*frameWidth + 10, sparThickness+10)
 chop.translate(Base.Vector(frameLength - halfSparThickness, -frameWidth, -1))
 triangles = triangles.cut(chop)

 frame = frame.fuse(triangles)

 # Maybe add fastenings in the corners

 if embeddedNutsInCorners:
   corner = Base.Vector(nutXY + nutWalls, 1 + nutXY + nutWalls - halfFrameWidth, 0)
   frame = frame.fuse(ScrewFastening(corner, True))
   frame = frame.cut(ScrewHole(corner, True))
   corner = Base.Vector(frameLength - nutXY - nutWalls, 1 + nutXY + nutWalls - halfFrameWidth, 0)
   frame = frame.fuse(ScrewFastening(corner, True))
   frame = frame.cut(ScrewHole(corner, True))
   corner = Base.Vector(frameLength - nutXY - nutWalls, halfFrameWidth - nutXY - nutWalls - 1, 0)
   frame = frame.fuse(ScrewFastening(corner, True))
   frame = frame.cut(ScrewHole(corner, True))
   corner = Base.Vector(nutXY + nutWalls, halfFrameWidth - nutXY - nutWalls - 1, 0)
   frame = frame.fuse(ScrewFastening(corner, True))
   frame = frame.cut(ScrewHole(corner, True))

 # finally cut away the chamfer allowing the frame to form into a triangle.

 frame = frame.cut(Chamfer30Cut())
 return frame



Part.show(FrameFace())

